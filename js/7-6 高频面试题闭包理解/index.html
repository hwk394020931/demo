<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>7-6 高频面试题闭包理解</title>
</head>
<body>
    <script>
        /*
            闭包(Closure)：作用域
            1、是引用了自由变量的函数这个被引用的自由变量将和这个函数一同存在，即使已经离开
            创造它的环境也不例外。所以，有另一个说法认为闭包是由函数和其相关的引用环境组合而成
            实现信息的驻留(信息的保持，引用在，空间不销毁)
        */

        //简单的闭包
        // var Person = function(){
        //     var count = 0;//私有的变量
        //     return function getCount(){
        //         console.log(count++);
        //     }
        // }
        // var p = Person();
        // p(); //0
        // p(); //1
        // p(); //2

        //应用
        var buttons=[{name:'b1'},{name:'b2'},{name:'b3'}];
        function bind(){
            // for(var i=0;i<buttons.length;i++){
            // //     button[i].onclick = function(){
            // //         alert(i)
            // //     }
            // //使用闭包解决alert 输出全是3，如何解决呢(只要把他值保留下来)
            // //使用即时执行函数
            //     (function(num){
            //         buttons[i].onclick=function(){
            //             alert(num);
            //         }
            //     })(i); //把这个i当做局部变量传入给num,保存了当前这个局部变量形成闭包
            // }

            //es6 使用let可以快速创建一闭包出来,let也是可以使数据驻留

            for(let i=0;i<buttons.length;i++){
                buttons[i].onclick = function(){
                    alert(i);
                }
            }
        }

        bind();
        //alert 全部都是3
        buttons[0].onclick(); 
        buttons[1].onclick();
        buttons[2].onclick();


        //闭包的缺点：闭包导致内存驻留，如果是大量对象的闭包环境注意内存消耗
    </script>
</body>
</html>